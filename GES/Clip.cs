// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace GES
{

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;

    using GStreamer;

    #region Autogenerated code
    public partial class Clip : GES.Container
    {

        protected Clip(IntPtr raw) : base(raw) { }

        protected Clip() : base(IntPtr.Zero)
        {
            CreateNativeObject(new string[0], new GLib.Value[0]);
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern ulong ges_clip_get_duration_limit(IntPtr raw);

        [GLib.Property("duration-limit")]
        public ulong DurationLimit
        {
            get
            {
                ulong raw_ret = ges_clip_get_duration_limit(Handle);
                ulong ret = raw_ret;
                return ret;
            }
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr ges_clip_get_layer(IntPtr raw);

        [GLib.Property("layer")]
        public GES.Layer Layer
        {
            get
            {
                IntPtr raw_ret = ges_clip_get_layer(Handle);
                GES.Layer ret = GLib.Object.GetObject(raw_ret, true) as GES.Layer;
                return ret;
            }
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern int ges_clip_get_supported_formats(IntPtr raw);

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern void ges_clip_set_supported_formats(IntPtr raw, int supportedformats);

        [GLib.Property("supported-formats")]
        public GES.TrackType SupportedFormats
        {
            get
            {
                int raw_ret = ges_clip_get_supported_formats(Handle);
                GES.TrackType ret = (GES.TrackType)raw_ret;
                return ret;
            }
            set
            {
                ges_clip_set_supported_formats(Handle, (int)value);
            }
        }


        // Internal representation of the wrapped structure ABI.
        static GLib.AbiStruct _class_abi = null;
        static public new GLib.AbiStruct class_abi
        {
            get
            {
                if (_class_abi == null)
                    _class_abi = new GLib.AbiStruct(new List<GLib.AbiField>{
                        new GLib.AbiField("create_track_element"
                            , GES.Container.class_abi.Fields
                            , (uint) Marshal.SizeOf(typeof(IntPtr)) // create_track_element
							, null
                            , "create_track_elements"
                            , (uint) Marshal.SizeOf(typeof(IntPtr))
                            , 0
                            ),
                        new GLib.AbiField("create_track_elements"
                            , -1
                            , (uint) Marshal.SizeOf(typeof(IntPtr)) // create_track_elements
							, "create_track_element"
                            , "ABI"
                            , (uint) Marshal.SizeOf(typeof(IntPtr))
                            , 0
                            ),
						// union struct ABI.abi
						// End ABI.abi

						// union struct ABI
							new GLib.AbiField("ABI._gst_reserved"
                                , -1
                                , (uint) Marshal.SizeOf(typeof(IntPtr)) * 20 // ABI._gst_reserved
								, "create_track_elements"
                                , null
                                , (uint) Marshal.SizeOf(typeof(IntPtr))
                                , 0
                                ),
						// End ABI

						new GLib.AbiField("ABI"
                            , -1
                            , new List<List<string>>() {  // union ABI
						new List<string>() {},
                        new List<string>() {"ABI._gst_reserved"}
                      }
                            , "create_track_elements"
                            , null
                            , 0
                            ),
                    });

                return _class_abi;
            }
        }


        // End of the ABI representation.

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr ges_clip_get_type();

        public static new GLib.GType GType
        {
            get
            {
                IntPtr raw_ret = ges_clip_get_type();
                GLib.GType ret = new GLib.GType(raw_ret);
                return ret;
            }
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr ges_clip_add_asset(IntPtr raw, IntPtr asset);

        public GES.TrackElement AddAsset(GES.Asset asset)
        {
            IntPtr raw_ret = ges_clip_add_asset(Handle, asset == null ? IntPtr.Zero : asset.Handle);
            GES.TrackElement ret = GLib.Object.GetObject(raw_ret) as GES.TrackElement;
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr ges_clip_add_child_to_track(IntPtr raw, IntPtr child, IntPtr track, out IntPtr error);

        public unsafe GES.TrackElement AddChildToTrack(GES.TrackElement child, GES.Track track)
        {
            IntPtr error = IntPtr.Zero;
            IntPtr raw_ret = ges_clip_add_child_to_track(Handle, child == null ? IntPtr.Zero : child.Handle, track == null ? IntPtr.Zero : track.Handle, out error);
            GES.TrackElement ret = GLib.Object.GetObject(raw_ret) as GES.TrackElement;
            if (error != IntPtr.Zero) throw new GLib.GException(error);
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe bool ges_clip_add_top_effect(IntPtr raw, IntPtr effect, int index, out IntPtr error);

        public unsafe bool AddTopEffect(GES.BaseEffect effect, int index)
        {
            IntPtr error = IntPtr.Zero;
            bool raw_ret = ges_clip_add_top_effect(Handle, effect == null ? IntPtr.Zero : effect.Handle, index, out error);
            bool ret = raw_ret;
            if (error != IntPtr.Zero) throw new GLib.GException(error);
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr ges_clip_find_track_element(IntPtr raw, IntPtr track, IntPtr type);

        public GES.TrackElement FindTrackElement(GES.Track track, GLib.GType type)
        {
            IntPtr raw_ret = ges_clip_find_track_element(Handle, track == null ? IntPtr.Zero : track.Handle, type.Val);
            GES.TrackElement ret = GLib.Object.GetObject(raw_ret, true) as GES.TrackElement;
            return ret;
        }

        public GES.TrackElement FindTrackElement(GLib.GType type)
        {
            return FindTrackElement(null, type);
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr ges_clip_find_track_elements(IntPtr raw, IntPtr track, int track_type, IntPtr type);

        public GES.TrackElement[] FindTrackElements(GES.Track track, GES.TrackType track_type, GLib.GType type)
        {
            IntPtr raw_ret = ges_clip_find_track_elements(Handle, track == null ? IntPtr.Zero : track.Handle, (int)track_type, type.Val);
            GES.TrackElement[] ret = (GES.TrackElement[])GLib.Marshaller.ListPtrToArray(raw_ret, typeof(GLib.List), true, true, typeof(GES.TrackElement));
            return ret;
        }

        public GES.TrackElement[] FindTrackElements(GES.TrackType track_type, GLib.GType type)
        {
            return FindTrackElements(null, track_type, type);
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe ulong ges_clip_get_internal_time_from_timeline_time(IntPtr raw, IntPtr child, ulong timeline_time, out IntPtr error);

        public unsafe ulong GetInternalTimeFromTimelineTime(GES.TrackElement child, ulong timeline_time)
        {
            IntPtr error = IntPtr.Zero;
            ulong raw_ret = ges_clip_get_internal_time_from_timeline_time(Handle, child == null ? IntPtr.Zero : child.Handle, timeline_time, out error);
            ulong ret = raw_ret;
            if (error != IntPtr.Zero) throw new GLib.GException(error);
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe ulong ges_clip_get_timeline_time_from_internal_time(IntPtr raw, IntPtr child, ulong internal_time, out IntPtr error);

        public unsafe ulong GetTimelineTimeFromInternalTime(GES.TrackElement child, ulong internal_time)
        {
            IntPtr error = IntPtr.Zero;
            ulong raw_ret = ges_clip_get_timeline_time_from_internal_time(Handle, child == null ? IntPtr.Zero : child.Handle, internal_time, out error);
            ulong ret = raw_ret;
            if (error != IntPtr.Zero) throw new GLib.GException(error);
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe ulong ges_clip_get_timeline_time_from_source_frame(IntPtr raw, long frame_number, out IntPtr error);

        public unsafe ulong GetTimelineTimeFromSourceFrame(long frame_number)
        {
            IntPtr error = IntPtr.Zero;
            ulong raw_ret = ges_clip_get_timeline_time_from_source_frame(Handle, frame_number, out error);
            ulong ret = raw_ret;
            if (error != IntPtr.Zero) throw new GLib.GException(error);
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern int ges_clip_get_top_effect_index(IntPtr raw, IntPtr effect);

        public int GetTopEffectIndex(GES.BaseEffect effect)
        {
            int raw_ret = ges_clip_get_top_effect_index(Handle, effect == null ? IntPtr.Zero : effect.Handle);
            int ret = raw_ret;
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern int ges_clip_get_top_effect_position(IntPtr raw, IntPtr effect);

        public int GetTopEffectPosition(GES.BaseEffect effect)
        {
            int raw_ret = ges_clip_get_top_effect_position(Handle, effect == null ? IntPtr.Zero : effect.Handle);
            int ret = raw_ret;
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr ges_clip_get_top_effects(IntPtr raw);

        public GES.TrackElement[] TopEffects
        {
            get
            {
                IntPtr raw_ret = ges_clip_get_top_effects(Handle);
                GES.TrackElement[] ret = (GES.TrackElement[])GLib.Marshaller.ListPtrToArray(raw_ret, typeof(GLib.List), true, true, typeof(GES.TrackElement));
                return ret;
            }
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern bool ges_clip_move_to_layer(IntPtr raw, IntPtr layer);

        public bool MoveToLayer(GES.Layer layer)
        {
            bool raw_ret = ges_clip_move_to_layer(Handle, layer == null ? IntPtr.Zero : layer.Handle);
            bool ret = raw_ret;
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe bool ges_clip_move_to_layer_full(IntPtr raw, IntPtr layer, out IntPtr error);

        public unsafe bool MoveToLayerFull(GES.Layer layer)
        {
            IntPtr error = IntPtr.Zero;
            bool raw_ret = ges_clip_move_to_layer_full(Handle, layer == null ? IntPtr.Zero : layer.Handle, out error);
            bool ret = raw_ret;
            if (error != IntPtr.Zero) throw new GLib.GException(error);
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe bool ges_clip_remove_top_effect(IntPtr raw, IntPtr effect, out IntPtr error);

        public unsafe bool RemoveTopEffect(GES.BaseEffect effect)
        {
            IntPtr error = IntPtr.Zero;
            bool raw_ret = ges_clip_remove_top_effect(Handle, effect == null ? IntPtr.Zero : effect.Handle, out error);
            bool ret = raw_ret;
            if (error != IntPtr.Zero) throw new GLib.GException(error);
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern bool ges_clip_set_top_effect_index(IntPtr raw, IntPtr effect, uint newindex);

        public bool SetTopEffectIndex(GES.BaseEffect effect, uint newindex)
        {
            bool raw_ret = ges_clip_set_top_effect_index(Handle, effect == null ? IntPtr.Zero : effect.Handle, newindex);
            bool ret = raw_ret;
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe bool ges_clip_set_top_effect_index_full(IntPtr raw, IntPtr effect, uint newindex, out IntPtr error);

        public unsafe bool SetTopEffectIndexFull(GES.BaseEffect effect, uint newindex)
        {
            IntPtr error = IntPtr.Zero;
            bool raw_ret = ges_clip_set_top_effect_index_full(Handle, effect == null ? IntPtr.Zero : effect.Handle, newindex, out error);
            bool ret = raw_ret;
            if (error != IntPtr.Zero) throw new GLib.GException(error);
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern bool ges_clip_set_top_effect_priority(IntPtr raw, IntPtr effect, uint newpriority);

        public bool SetTopEffectPriority(GES.BaseEffect effect, uint newpriority)
        {
            bool raw_ret = ges_clip_set_top_effect_priority(Handle, effect == null ? IntPtr.Zero : effect.Handle, newpriority);
            bool ret = raw_ret;
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr ges_clip_split(IntPtr raw, ulong position);

        public GES.Clip Split(ulong position)
        {
            IntPtr raw_ret = ges_clip_split(Handle, position);
            GES.Clip ret = GLib.Object.GetObject(raw_ret) as GES.Clip;
            return ret;
        }

        [DllImport(DLL.GES, CallingConvention = CallingConvention.Cdecl)]
        static extern unsafe IntPtr ges_clip_split_full(IntPtr raw, ulong position, out IntPtr error);

        public unsafe GES.Clip SplitFull(ulong position)
        {
            IntPtr error = IntPtr.Zero;
            IntPtr raw_ret = ges_clip_split_full(Handle, position, out error);
            GES.Clip ret = GLib.Object.GetObject(raw_ret) as GES.Clip;
            if (error != IntPtr.Zero) throw new GLib.GException(error);
            return ret;
        }


        static Clip()
        {
            GtkSharp.GstEditingServices.ObjectManager.Initialize();
        }

        // Internal representation of the wrapped structure ABI.
        static GLib.AbiStruct _abi_info = null;
        static public new GLib.AbiStruct abi_info
        {
            get
            {
                if (_abi_info == null)
                    _abi_info = new GLib.AbiStruct(new List<GLib.AbiField>{
                        new GLib.AbiField("priv"
                            , GES.Container.abi_info.Fields
                            , (uint) Marshal.SizeOf(typeof(IntPtr)) // priv
							, null
                            , "_ges_reserved"
                            , (uint) Marshal.SizeOf(typeof(IntPtr))
                            , 0
                            ),
                        new GLib.AbiField("_ges_reserved"
                            , -1
                            , (uint) Marshal.SizeOf(typeof(IntPtr)) * 20 // _ges_reserved
							, "priv"
                            , null
                            , (uint) Marshal.SizeOf(typeof(IntPtr))
                            , 0
                            ),
                    });

                return _abi_info;
            }
        }


        // End of the ABI representation.

        #endregion
    }
}
